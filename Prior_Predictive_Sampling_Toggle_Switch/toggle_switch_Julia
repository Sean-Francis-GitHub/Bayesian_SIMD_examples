# This script attempts to recreate toggle switch code
using Distributions
using Random
using Statistics
using BenchmarkTools
using Distributed

# Add worker processes
P = Sys.CPU_THREADS
addprocs(P)

@everywhere using Random
@everywhere using Statistics
@everywhere using Distributions

@everywhere function simulate_toggle_switch_vec(mu, sigma, gam, alpha, beta, T, C)
    u_t = Vector{Float64}(undef, C)
    v_t = Vector{Float64}(undef, C)

    alpha_u = alpha[1]
    alpha_v = alpha[2]
    beta_u = beta[1]
    beta_v = beta[2]

    u_t .= 10.0
    v_t .= 10.0

    # Generate random variates
    zeta = rand(Normal(0, 1), C, 2*(T - 1) + 1)

    for j = 2:T
        p_u = v_t .^ beta_u
        p_v = u_t .^ beta_v

        u_t = 0.97 .* u_t .+ alpha_u ./ (1 .+ p_u) .- 1.0 .+ 0.5 .* zeta[1:C, 2*(j - 1)]
        v_t = 0.97 .* v_t .+ alpha_v ./ (1 .+ p_v) .- 1.0 .+ 0.5 .* zeta[1:C, 2*(j - 1) + 1]

        u_t[u_t .< 1.0] .= 1.0
        v_t[v_t .< 1.0] .= 1.0
    end

    y = u_t .+ sigma .* mu .* zeta[1:C, 1] ./ (u_t .^ gam)
    y[y .< 1.0] .= 1.0

    return y
end

@everywhere function generate_sample(T, C)
    theta = rand.(Uniform.(
        [250.0, 0.05, 0.05, 0.0, 0.0, 0.0, 0.0],
        [400.0, 0.5, 0.35, 50.0, 50.0, 7.0, 7.0]
    ))

    mu = theta[1]
    sigma = theta[2]
    gam = theta[3]
    alpha = theta[4:5]
    beta = theta[6:7]

    result = simulate_toggle_switch_vec(mu, sigma, gam, alpha, beta, T, C)
    return vcat(theta, result)  # Combine theta and simulation output
end

# Prior predictive sampling parameters
T = 600
C = 8000
N = 8064

# Time the parallel execution
open("output_Julia_runtime.log", "w") do io
    t_start = time()
    obs_vals2 = pmap(x -> generate_sample(T, C), 1:N)
    t_end = time()
    println(io, "Execution time: $(t_end - t_start) seconds")
end

println((P, N, C, T))
